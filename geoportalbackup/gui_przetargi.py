import customtkinter as ctk
import subprocess
import os
import datetime
import threading
from tkinter import filedialog
import json
import sys
import importlib.util

# Funkcja do znajdowania ≈õcie≈ºki do plik√≥w zasob√≥w
def resource_path(relative_path):
    """ Zwraca bezwzglƒôdnƒÖ ≈õcie≈ºkƒô do zasobu, dzia≈Ça zar√≥wno w trybie development jak i po zapakowaniu """
    try:
        # PyInstaller tworzy folder tymczasowy i przechowuje w nim ≈õcie≈ºkƒô w _MEIPASS
        base_path = sys._MEIPASS
    except Exception:
        base_path = os.path.abspath(".")
        
    return os.path.join(base_path, relative_path)

# Konfiguracja stylu GUI
ctk.set_appearance_mode("dark")  # zawsze u≈ºywaj ciemnego motywu
ctk.set_default_color_theme("blue")  # niebieski akcent

class PrzetargiApp(ctk.CTk):
    def __init__(self):
        super().__init__()

        self.title("Geoportal Przetargi - Panel ZarzƒÖdzania")
        self.geometry("1400x800")  # Zwiƒôkszony rozmiar okna z 1100x700 na 1300x800
        
        # Dodajemy ikonƒô aplikacji z pliku PNG
        try:
            icon_path = resource_path("3082383.png")
            # Na Windows u≈ºywamy iconbitmap
            if sys.platform.startswith('win'):
                # Na Windows potrzebujemy ikony .ico, ale mo≈ºemy u≈ºyƒá PhotoImage dla okien toplevel
                from PIL import Image, ImageTk
                self.icon_img = ImageTk.PhotoImage(Image.open(icon_path))
                self.iconphoto(True, self.icon_img)
            elif sys.platform.startswith('darwin'):  # macOS
                # Na macOS mo≈ºna u≈ºyƒá iconphoto z PhotoImage
                from PIL import Image, ImageTk
                self.icon_img = ImageTk.PhotoImage(Image.open(icon_path))
                self.iconphoto(True, self.icon_img)
        except Exception as e:
            print(f"Nie uda≈Ço siƒô ustawiƒá ikony aplikacji: {e}")
        
        # Zmienne
        self.current_page = "Strona G≈Ç√≥wna"
        self.recent_files = []
        self.load_recent_files()
        self.przetargi_data = {}
        self.load_przetargi_data()

        # Sidebar - zwiƒôkszona szeroko≈õƒá z 220 na 250 pikseli
        self.sidebar = ctk.CTkFrame(self, width=250, corner_radius=0)
        self.sidebar.pack(side="left", fill="y")

        # Logo z wiƒôkszym marginesem wewnƒôtrznym
        self.logo = ctk.CTkLabel(self.sidebar, text="üóÇ Geoportal Przetargi", 
                              font=("Arial", 20, "bold"),
                              padx=15)  # Dodany padding poziomy
        self.logo.pack(pady=20, padx=15)  # Dodany padding do packowania
        
        # Separator - szerszy ni≈º poprzednio
        separator = ctk.CTkFrame(self.sidebar, height=2, width=220)
        separator.pack(pady=10)

        # Menu ikony
        icons = {
            "Strona G≈Ç√≥wna": "üè†",
            "Rzeszowski": "üèôÔ∏è",
            "≈Åa≈Ñcucki": "üèõÔ∏è",
            "Ropczycko-Sƒôdziszowski": "üè¢"
        }
        
        self.buttons = []
        for name, icon in icons.items():
            btn = ctk.CTkButton(
                self.sidebar, 
                text=f"{icon} {name}", 
                command=lambda n=name: self.show_page(n),
                anchor="w", 
                height=40,
                fg_color=("gray80", "gray30") if name == self.current_page else "transparent",
                text_color=("gray10", "gray90"),
                hover_color=("gray70", "gray40")
            )
            # Zwiƒôkszone marginesy dla przycisk√≥w
            btn.pack(pady=8, fill="x", padx=15)
            self.buttons.append((name, btn))
        
        # Informacja o wersji na dole sidebar z dodanym paddingiem
        version_frame = ctk.CTkFrame(self.sidebar, fg_color="transparent")
        version_frame.pack(side="bottom", fill="x", pady=15)
        version_label = ctk.CTkLabel(version_frame, text="v1.2.0", text_color="gray50")
        version_label.pack(padx=15)  # Dodany padding poziomy

        # Kontener na strony - zwiƒôkszony padding od lewej strony
        self.pages_container = ctk.CTkFrame(self, fg_color="transparent")
        self.pages_container.pack(side="right", fill="both", expand=True)
        
        # Mapowanie nazw powiat√≥w do wzorc√≥w wyszukiwania
        self.powiat_patterns = {
            "Rzeszowski": ["rzeszowski"],
            "≈Åa≈Ñcucki": ["≈Ça≈Ñcucki", "≈Çancuck"],
            "Ropczycko-Sƒôdziszowski": ["ropczyck", "sƒôdziszow", "sedziszow"]
        }
        
        # Tworzenie stron
        self.pages = {
            "Strona G≈Ç√≥wna": self.create_main_page(),
            "Rzeszowski": self.create_powiat_page("Powiat Rzeszowski"),
            "≈Åa≈Ñcucki": self.create_powiat_page("Powiat ≈Åa≈Ñcucki"),
            "Ropczycko-Sƒôdziszowski": self.create_powiat_page("Powiat Ropczycko-Sƒôdziszowski")
        }

        self.show_page("Strona G≈Ç√≥wna")
        
    def load_przetargi_data(self):
        """Wczytuje dane z pliku przetargi_najlepsze_oferty.json"""
        try:
            with open(resource_path('przetargi_najlepsze_oferty.json'), 'r', encoding='utf-8') as f:
                self.przetargi_data = json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            self.przetargi_data = {"przetargi": []}
            print("B≈ÇƒÖd podczas ≈Çadowania przetargi_najlepsze_oferty.json")
            
    def refresh_data(self):
        # Od≈õwie≈ºamy dane
        self.load_przetargi_data()
        self.load_recent_files()
        
        # Aktualizujemy statystyki na stronie g≈Ç√≥wnej
        stats = self.get_stats()
        
        # Aktualizujemy warto≈õci na kartach statystyk
        if hasattr(self, 'stat_cards'):
            self.stat_cards["total"].configure(text=str(stats["total"]))
            self.stat_cards["active"].configure(text=str(stats["active"]))
            self.stat_cards["rolne"].configure(text=str(stats["rolne"]))
            
        # Aktualizujemy listƒô ostatnich plik√≥w
        self.update_recent_files_list()
        
        # Aktualizujemy dane w zak≈Çadkach z powiatami
        self.update_powiat_data()
        
        # Pokazujemy komunikat o od≈õwie≈ºeniu
        if hasattr(self, 'status_label'):
            self.status_label.configure(text="‚úì Dane zosta≈Çy od≈õwie≈ºone", text_color="#4CAF50")
            # Usuwamy komunikat po 3 sekundach
            self.after(3000, lambda: self.status_label.configure(text=""))
            
    def update_powiat_data(self):
        """Aktualizuje dane w zak≈Çadkach z powiatami"""
        for powiat_name in ["Rzeszowski", "≈Åa≈Ñcucki", "Ropczycko-Sƒôdziszowski"]:
            if powiat_name in self.pages:
                # Sprawd≈∫ czy zak≈Çadka ma przypisany kontener na dane
                if hasattr(self, f'{powiat_name.lower()}_data_container'):
                    container = getattr(self, f'{powiat_name.lower()}_data_container')
                    
                    # Wyczy≈õƒá istniejƒÖce elementy
                    for widget in container.winfo_children():
                        widget.destroy()
                    
                    # Pobierz przetargi dla tego powiatu
                    przetargi = self.get_przetargi_for_powiat(powiat_name)
                    
                    if not przetargi:
                        no_data = ctk.CTkLabel(container, text=f"Brak przetarg√≥w dla powiatu {powiat_name}", 
                                             font=("Arial", 14), text_color="#555555")
                        no_data.pack(pady=20)
                    else:
                        # Utw√≥rz nag≈Ç√≥wki tabeli - zwiƒôkszone marginesy z 10 na 15
                        headers_frame = ctk.CTkFrame(container, fg_color="#1E3A8A")  # T≈Ço nag≈Ç√≥wk√≥w - ciemny niebieski
                        headers_frame.pack(fill="x", pady=(0, 8), padx=15)  # Zwiƒôkszone marginesy
                        
                        header_color = "#FFFFFF"  # Bia≈Çy kolor dla tekstu nag≈Ç√≥wk√≥w
                        
                        ctk.CTkLabel(headers_frame, text="LP", width=50, anchor="w", 
                                    font=("Arial", 12, "bold"), 
                                    text_color=header_color).pack(side="left", padx=(15, 10))  # Zwiƒôkszony lewy margines
                        ctk.CTkLabel(headers_frame, text="Data", width=100, anchor="w",
                                    font=("Arial", 12, "bold"),
                                    text_color=header_color).pack(side="left", padx=15)  # Zwiƒôkszone marginesy
                        ctk.CTkLabel(headers_frame, text="Po≈Ço≈ºenie", width=250, anchor="w",
                                   font=("Arial", 12, "bold"),
                                   text_color=header_color).pack(side="left", padx=15)  # Zwiƒôkszone marginesy
                        ctk.CTkLabel(headers_frame, text="Rodzaj", width=100, anchor="w",
                                   font=("Arial", 12, "bold"),
                                   text_color=header_color).pack(side="left", padx=15)  # Zwiƒôkszone marginesy
                        ctk.CTkLabel(headers_frame, text="Powierzchnia", width=100, anchor="w",
                                   font=("Arial", 12, "bold"),
                                   text_color=header_color).pack(side="left", padx=15)  # Zwiƒôkszone marginesy
                        ctk.CTkLabel(headers_frame, text="Cena (PLN)", width=100, anchor="w",
                                   font=("Arial", 12, "bold"),
                                   text_color=header_color).pack(side="left", padx=15)  # Zwiƒôkszone marginesy
                        
                        # Separator z wiƒôkszymi marginesami
                        separator = ctk.CTkFrame(container, height=2, fg_color="#1E3A8A")
                        separator.pack(fill="x", padx=15, pady=8)  # Zwiƒôkszone marginesy
                        
                        # Kontener na scrollowanie z wiƒôkszymi marginesami
                        scroll_frame = ctk.CTkScrollableFrame(container, fg_color="transparent")
                        scroll_frame.pack(fill="both", expand=True, padx=15, pady=10)  # Zwiƒôkszone marginesy
                        
                        # Kolory wierszy
                        row_colors = [("#F3F4F6", "#1F2937"), ("#E5E7EB", "#374151")]  # (t≈Ço, tekst) dla parzystych i nieparzystych
                        
                        # Dodaj przetargi
                        for i, przetarg in enumerate(przetargi[:30]):  # Ogranicz do 30 pozycji
                            bg_color, text_color = row_colors[i % 2]
                            
                            # Utw√≥rz ramkƒô dla ca≈Çego wiersza
                            row_frame = ctk.CTkFrame(scroll_frame, fg_color=bg_color, corner_radius=6)
                            row_frame.pack(fill="x", pady=3, ipady=6)  # Zwiƒôkszone marginesy
                            
                            # Zapisz oryginalne kolory do p√≥≈∫niejszego u≈ºycia w animacjach
                            row_frame.original_bg = bg_color
                            row_frame.original_text = text_color
                            
                            # LP z wiƒôkszym marginesem
                            lp_label = ctk.CTkLabel(row_frame, text=przetarg.get("lp", ""), 
                                      width=50, anchor="w",
                                      text_color=text_color)
                            lp_label.pack(side="left", padx=(15, 10))  # Zwiƒôkszony lewy margines
                            
                            # Data z wiƒôkszym marginesem
                            data = przetarg.get("data_godzina", "").split("\n")[0] if przetarg.get("data_godzina") else ""
                            data_label = ctk.CTkLabel(row_frame, text=data, 
                                       width=100, anchor="w",
                                       text_color=text_color)
                            data_label.pack(side="left", padx=15)  # Zwiƒôkszone marginesy
                            
                            # Po≈Ço≈ºenie (skr√≥cone) z wiƒôkszym marginesem
                            polozenie = przetarg.get("po≈Ço≈ºenie", "")
                            if len(polozenie) > 30:
                                polozenie = polozenie[:27] + "..."
                            polozenie_label = ctk.CTkLabel(row_frame, text=polozenie, 
                                       width=250, anchor="w",
                                       text_color=text_color)
                            polozenie_label.pack(side="left", padx=15)  # Zwiƒôkszone marginesy
                            
                            # Rodzaj z wiƒôkszym marginesem
                            rodzaj = przetarg.get("typ_nieruchomo≈õci", "")
                            rodzaj_label = ctk.CTkLabel(row_frame, text=rodzaj, 
                                       width=100, anchor="w",
                                       text_color=text_color)
                            rodzaj_label.pack(side="left", padx=15)  # Zwiƒôkszone marginesy
                            
                            # Powierzchnia z wiƒôkszym marginesem
                            powierzchnia = str(przetarg.get("powierzchnia_ogolna", "")) + " ha"
                            powierzchnia_label = ctk.CTkLabel(row_frame, text=powierzchnia, 
                                       width=100, anchor="w",
                                       text_color=text_color)
                            powierzchnia_label.pack(side="left", padx=15)  # Zwiƒôkszone marginesy
                            
                            # Cena z wiƒôkszym marginesem
                            cena = f"{przetarg.get('cena_wywo≈Çawcza', 0):,.2f}".replace(",", " ")
                            cena_label = ctk.CTkLabel(row_frame, text=cena, 
                                       width=100, anchor="w",
                                       text_color=text_color)
                            cena_label.pack(side="left", padx=15)  # Zwiƒôkszone marginesy
                            
                            # Przycisk szczeg√≥≈Ç√≥w z wiƒôkszym marginesem
                            details_btn = ctk.CTkButton(row_frame, text="Szczeg√≥≈Çy", 
                                                     width=80, height=28,  # Nieznacznie wiƒôkszy przycisk
                                                     command=lambda p=przetarg: self.show_przetarg_details(p),
                                                     fg_color="#2563EB",
                                                     hover_color="#1D4ED8")
                            details_btn.pack(side="right", padx=15)  # Zwiƒôkszony margines

                            # Funkcje animacji przy klikniƒôciu
                            def on_click(event, frame=row_frame, p=przetarg):
                                # Animacja klikniƒôcia - zmiana koloru t≈Ça na niebieski
                                frame.configure(fg_color="#2563EB")  # Jasny niebieski
                                
                                # Pokazanie u≈ºytkownikowi, ≈ºe nastƒÖpi≈Ço klikniƒôcie
                                self.status_label.configure(text="Otwieranie geoportalu...", text_color="#FFB74D")
                                
                                # Ustaw wszystkie etykiety na bia≈Çy tekst
                                for child in frame.winfo_children():
                                    if isinstance(child, ctk.CTkLabel):
                                        child.configure(text_color="#FFFFFF")
                                
                                # Op√≥≈∫nione przywr√≥cenie oryginalnych kolor√≥w po 150ms
                                self.after(150, lambda: restore_color(frame))
                                
                                # Po zako≈Ñczeniu animacji, wywo≈Çaj funkcjƒô otwierajƒÖcƒÖ geoportal
                                self.open_geoportal(p)
                            
                            def restore_color(frame):
                                # Przywr√≥cenie oryginalnych kolor√≥w
                                frame.configure(fg_color=frame.original_bg)
                                
                                # Przywr√≥ƒá oryginalny kolor tekstu dla wszystkich etykiet
                                for child in frame.winfo_children():
                                    if isinstance(child, ctk.CTkLabel):
                                        child.configure(text_color=frame.original_text)
                            
                            # Dodanie obs≈Çugi pojedynczego klikniƒôcia dla ca≈Çego wiersza
                            row_frame.bind("<Button-1>", on_click)
                            
                            # Dodanie kursora "hand" gdy myszka jest nad wierszem
                            row_frame.bind("<Enter>", lambda e, frame=row_frame: frame.configure(cursor="hand2"))
                            row_frame.bind("<Leave>", lambda e, frame=row_frame: frame.configure(cursor=""))
                            
                            # Dodanie tych samych zdarze≈Ñ dla wszystkich etykiet w wierszu
                            for child in row_frame.winfo_children():
                                if isinstance(child, ctk.CTkLabel):
                                    child.bind("<Button-1>", lambda e, frame=row_frame, p=przetarg: on_click(e, frame, p))
                                    child.bind("<Enter>", lambda e, frame=row_frame: frame.configure(cursor="hand2"))
                                    child.bind("<Leave>", lambda e, frame=row_frame: frame.configure(cursor=""))

                            # Klikniƒôcie w przycisk szczeg√≥≈Ç√≥w powinno tylko pokazaƒá szczeg√≥≈Çy, a nie otwieraƒá geoportal
                            details_btn.bind("<Button-1>", lambda e: e.widget.invoke(), add="+")
                            # Zatrzymaj propagacjƒô zdarzenia klikniƒôcia
                            details_btn.bind("<Button-1>", lambda e: "break", add="+")
                            
    def get_przetargi_for_powiat(self, powiat_name):
        """Zwraca przetargi dla danego powiatu"""
        if not self.przetargi_data or "przetargi" not in self.przetargi_data:
            return []
            
        przetargi = []
        patterns = self.powiat_patterns.get(powiat_name, [])
        
        for przetarg in self.przetargi_data.get("przetargi", []):
            polozenie = przetarg.get("po≈Ço≈ºenie", "").lower()
            
            # Sprawd≈∫ czy ten przetarg pasuje do wzorc√≥w dla danego powiatu
            if any(pattern in polozenie for pattern in patterns):
                przetargi.append(przetarg)
                
        # Sortuj wed≈Çug daty (najnowsze najpierw)
        przetargi.sort(key=lambda p: self.extract_date_for_sort(p.get("data_godzina", "")), reverse=False)
        
        return przetargi
        
    def extract_date_for_sort(self, data_str):
        """Ekstrahuje datƒô z formatu DD.MM.YYYY do sortowania"""
        try:
            if not data_str:
                return datetime.datetime(2100, 1, 1)  # Data w przysz≈Ço≈õci dla pustych dat
                
            data_parts = data_str.split("\n")[0].split(".")
            if len(data_parts) >= 3:
                dzien, miesiac, rok = map(int, data_parts)
                return datetime.datetime(rok, miesiac, dzien)
            return datetime.datetime(2100, 1, 1)
        except:
            return datetime.datetime(2100, 1, 1)
            
    def show_przetarg_details(self, przetarg):
        """Wy≈õwietla okno z szczeg√≥≈Çami przetargu"""
        details_window = ctk.CTkToplevel(self)
        details_window.title("Szczeg√≥≈Çy przetargu")
        details_window.geometry("600x500")
        details_window.grab_set()  # Zablokuj interakcjƒô z g≈Ç√≥wnym oknem
        
        # Zapobieganie utracie referencji do okna (b≈ÇƒÖd w niekt√≥rych systemach)
        details_window.master = self
        
        # Nag≈Ç√≥wek
        header = ctk.CTkLabel(details_window, text=f"Przetarg #{przetarg.get('lp', '')}", 
                             font=("Arial", 18, "bold"))
        header.pack(pady=10)
        
        # Kontener na dane
        content = ctk.CTkFrame(details_window)
        content.pack(fill="both", expand=True, padx=20, pady=10)
        
        # Wy≈õwietl wszystkie pola przetargu
        row = 0
        for key, value in przetarg.items():
            # Zamie≈Ñ nazwy kluczy na bardziej czytelne
            display_key = {
                "lp": "Numer przetargu",
                "data_godzina": "Data i godzina",
                "miejsce": "Miejsce",
                "po≈Ço≈ºenie": "Po≈Ço≈ºenie",
                "forma": "Forma",
                "rodzaj_przetargu": "Rodzaj przetargu",
                "typ_nieruchomo≈õci": "Typ nieruchomo≈õci",
                "charakter_nieruchomo≈õci": "Charakter nieruchomo≈õci",
                "obni≈ºka": "Obni≈ºka",
                "atrybuty": "Atrybuty",
                "powierzchnia_ogolna": "Powierzchnia og√≥lna (ha)",
                "powierzchnia_ur": "Powierzchnia UR (ha)",
                "cena_wywo≈Çawcza": "Cena wywo≈Çawcza (PLN)",
                "kolejny_przetarg": "Kolejny przetarg",
                "uwagi": "Uwagi"
            }.get(key, key)
            
            # Formatuj warto≈õƒá
            if key == "cena_wywo≈Çawcza" and value is not None:
                display_value = f"{value:,.2f}".replace(",", " ")
            elif isinstance(value, (int, float)) and value is not None:
                display_value = str(value)
            elif value is None:
                display_value = "-"
            else:
                display_value = str(value).replace("\n", " ")
                
            # Etykieta klucza
            key_label = ctk.CTkLabel(content, text=display_key + ":", 
                                   anchor="e", width=150, 
                                   font=("Arial", 12, "bold"))
            key_label.grid(row=row, column=0, sticky="e", padx=(10, 5), pady=5)
            
            # Warto≈õƒá
            value_label = ctk.CTkLabel(content, text=display_value, 
                                     anchor="w", width=350,
                                     font=("Arial", 12))
            value_label.grid(row=row, column=1, sticky="w", padx=(5, 10), pady=5)
            
            row += 1
            
        # Przycisk zamkniƒôcia
        close_btn = ctk.CTkButton(details_window, text="Zamknij", 
                               command=details_window.destroy,
                               width=120, height=32)
        close_btn.pack(pady=15)

    def open_geoportal(self, przetarg):
        """Otwiera geoportal dla wybranego przetargu"""
        try:
            # Pokazujemy informacjƒô u≈ºytkownikowi
            self.status_label.configure(text="Otwieranie geoportalu...", text_color="#FFB74D")
            self.update()
            
            # Pobieramy po≈Ço≈ºenie dzia≈Çki
            polozenie = przetarg.get("po≈Ço≈ºenie", "")
            
            if not polozenie:
                self.status_label.configure(text="‚ùå Brak informacji o po≈Ço≈ºeniu dzia≈Çki", text_color="#F44336")
                self.after(3000, lambda: self.status_label.configure(text=""))
                return
            
            # Importujemy modu≈Ç otworz_geoportal.py
            try:
                # Utw√≥rz funkcjƒô callback do logowania
                def log_callback(message):
                    print(f"Geoportal: {message}")
                    self.status_label.configure(text=message, text_color="#4CAF50")
                    self.update()
                
                # Bezpo≈õrednio importuj funkcjƒô z modu≈Çu (bez specyfikacji ≈õcie≈ºki)
                from otworz_geoportal import get_powiat_from_polozenie, parse_dzialka_info, search_dzialka_selenium
                
                # Wyodrƒôbnij informacje o dzia≈Çce i powiecie
                powiat = get_powiat_from_polozenie(polozenie)
                dzialka_info = parse_dzialka_info(polozenie)
                
                if not powiat or not dzialka_info:
                    self.status_label.configure(text="‚ùå Nie uda≈Ço siƒô rozpoznaƒá po≈Ço≈ºenia dzia≈Çki", text_color="#F44336")
                    self.after(3000, lambda: self.status_label.configure(text=""))
                    return
                
                # Poka≈º informacjƒô o rozpoczƒôciu wyszukiwania
                self.status_label.configure(
                    text=f"‚úì Uruchamiam geoportal dla powiatu {powiat}. Proszƒô czekaƒá...", 
                    text_color="#4CAF50"
                )
                
                # Uruchom wyszukiwanie w osobnym wƒÖtku, aby nie blokowaƒá GUI
                def run_search_thread():
                    try:
                        # Bezpo≈õrednie wywo≈Çanie funkcji search_dzialka_selenium
                        search_dzialka_selenium(powiat, dzialka_info, log_callback)
                    except Exception as e:
                        print(f"B≈ÇƒÖd w run_search_thread: {e}")
                        import traceback
                        traceback.print_exc()
                        self.status_label.configure(
                            text=f"‚ùå B≈ÇƒÖd: {str(e)}", 
                            text_color="#F44336"
                        )
                
                # Uruchom w osobnym wƒÖtku, aby nie blokowaƒá GUI
                search_thread = threading.Thread(target=run_search_thread, daemon=True)
                search_thread.start()
                
            except Exception as e:
                print(f"B≈ÇƒÖd podczas importowania modu≈Çu otworz_geoportal: {e}")
                import traceback
                traceback.print_exc()
                
                # Komunikat dla u≈ºytkownika
                self.status_label.configure(
                    text=f"‚ö†Ô∏è Problem z modu≈Çem geoportalu: {str(e)}", 
                    text_color="#FFB74D"
                )
                
            # Resetujemy status po czasie
            self.after(5000, lambda: self.status_label.configure(text=""))
            
        except Exception as e:
            # W przypadku b≈Çƒôdu, wy≈õwietlamy informacjƒô
            self.status_label.configure(
                text=f"‚ùå B≈ÇƒÖd podczas otwierania geoportalu: {str(e)}", 
                text_color="#F44336"
            )
            print(f"B≈ÇƒÖd podczas otwierania geoportalu: {str(e)}")
            import traceback
            traceback.print_exc()
            self.after(3000, lambda: self.status_label.configure(text=""))

    def append_to_log(self, message):
        """
        Dodaje wiadomo≈õƒá do statusu i aktualizuje interfejs
        
        Args:
            message: Komunikat do wy≈õwietlenia
        """
        # Wy≈õwietl wiadomo≈õƒá w etykiecie statusu
        self.status_label.configure(text=message)
        
        # Od≈õwie≈º interfejs
        self.update()

    def run_chrome_diagnostics(self):
        """
        Uruchamia diagnostykƒô ≈õrodowiska Chrome i ChromeDriver
        """
        try:
            # Importuj modu≈Ç otworz_geoportal
            from otworz_geoportal import debug_chrome_environment
            
            # Utw√≥rz nowe okno z logami diagnostycznymi
            diagnostic_window = ctk.CTkToplevel(self)
            diagnostic_window.title("Diagnostyka Chrome i ChromeDriver")
            diagnostic_window.geometry("800x600")
            diagnostic_window.grab_set()  # Zablokuj interakcjƒô z g≈Ç√≥wnym oknem
            
            # Zapobieganie utracie referencji do okna
            diagnostic_window.master = self
            
            # Nag≈Ç√≥wek
            header = ctk.CTkLabel(diagnostic_window, text="Diagnostyka Chrome i ChromeDriver",
                                font=("Arial", 18, "bold"))
            header.pack(pady=10)
            
            # Obszar na logi
            log_frame = ctk.CTkFrame(diagnostic_window)
            log_frame.pack(fill="both", expand=True, padx=20, pady=10)
            
            # Scrollowany obszar tekstowy na logi
            log_scroll = ctk.CTkScrollableFrame(log_frame)
            log_scroll.pack(fill="both", expand=True)
            
            # Obszar tekstowy na logi
            log_area = ctk.CTkTextbox(log_scroll, wrap="word", height=400)
            log_area.pack(fill="both", expand=True, padx=10, pady=10)
            log_area.configure(state="normal")
            
            # Funkcja do dodawania tekstu do logu
            def log_callback(message):
                log_area.configure(state="normal")
                log_area.insert("end", message + "\n")
                log_area.see("end")
                log_area.configure(state="disabled")
                diagnostic_window.update()
                
            # Informacja w g≈Ç√≥wnym oknie
            self.status_label.configure(text="Uruchamiam diagnostykƒô Chrome i ChromeDriver...", text_color="#FFB74D")
            self.update()
            
            # Uruchom diagnostykƒô
            log_callback("Rozpoczynam diagnostykƒô Chrome i ChromeDriver...\n")
            debug_chrome_environment(log_callback)
            log_callback("\nDiagnostyka zako≈Ñczona.")
            
            # Przycisk zamkniƒôcia
            close_btn = ctk.CTkButton(diagnostic_window, text="Zamknij", 
                                   command=diagnostic_window.destroy,
                                   width=120, height=32)
            close_btn.pack(pady=15)
            
            # Zaktualizuj status w g≈Ç√≥wnym oknie
            self.status_label.configure(text="Diagnostyka zako≈Ñczona. Sprawd≈∫ wyniki w nowym oknie.", text_color="#4CAF50")
            
        except Exception as e:
            # W przypadku b≈Çƒôdu
            self.status_label.configure(text=f"‚ùå B≈ÇƒÖd diagnostyki: {str(e)}", text_color="#F44336")
            print(f"B≈ÇƒÖd podczas uruchamiania diagnostyki: {e}")
            import traceback
            traceback.print_exc()

    def show_page(self, name):
        # Ukryj wszystkie strony
        for page in self.pages.values():
            page.pack_forget()
            
        # Wy≈õwietl wybranƒÖ stronƒô - zwiƒôkszone marginesy z 20 na 25
        self.pages[name].pack(fill="both", expand=True, padx=25, pady=25)
        
        # Zaktualizuj stan przycisk√≥w
        self.current_page = name
        for btn_name, btn in self.buttons:
            if btn_name == name:
                btn.configure(fg_color=("gray80", "gray30"))
            else:
                btn.configure(fg_color="transparent")
        
        # Od≈õwie≈º dane je≈õli wracamy na stronƒô g≈Ç√≥wnƒÖ lub wybrali≈õmy zak≈Çadkƒô z powiatem
        if name == "Strona G≈Ç√≥wna":
            self.refresh_data()
        elif name in self.powiat_patterns:
            self.update_powiat_data()

    def create_main_page(self):
        frame = ctk.CTkFrame(self.pages_container)
        
        # Nag≈Ç√≥wek z wiƒôkszym marginesem
        header_frame = ctk.CTkFrame(frame, fg_color="transparent")
        header_frame.pack(fill="x", pady=15) # Zwiƒôkszony padding g√≥rny i dolny
        
        title = ctk.CTkLabel(header_frame, text="Panel Przetarg√≥w", font=("Arial", 26, "bold"))
        title.pack(side="left", padx=15) # Dodany padding poziomy
        
        date_label = ctk.CTkLabel(header_frame, text=f"Data: {datetime.date.today().strftime('%d.%m.%Y')}", 
                                font=("Arial", 16))
        date_label.pack(side="right", padx=15) # Dodany padding poziomy
        
        # Linia podzia≈Çu
        separator = ctk.CTkFrame(frame, height=2)
        separator.pack(fill="x", pady=12, padx=15) # Zwiƒôkszone marginesy
        
        # Informacje og√≥lne
        info_frame = ctk.CTkFrame(frame)
        info_frame.pack(fill="x", pady=15, padx=15) # Dodany padding poziomy
        
        stats_frame = ctk.CTkFrame(info_frame, fg_color="transparent")
        stats_frame.pack(pady=20, padx=25) # Zwiƒôkszone marginesy
        
        # Pobieramy statystyki z pliku JSON
        stats = self.get_stats()
        
        # Statystyki w kartach
        cards_frame = ctk.CTkFrame(stats_frame, fg_color="transparent")
        cards_frame.pack(fill="x")
        
        # Tworzenie kart statystyk i zapisanie referencji do etykiet z warto≈õciami
        self.stat_cards = {}
        self.stat_cards["total"] = self.create_stat_card(cards_frame, "Wszystkie przetargi", str(stats.get("total", "0")), 0)
        self.stat_cards["active"] = self.create_stat_card(cards_frame, "Aktywne", str(stats.get("active", "0")), 1)
        self.stat_cards["rolne"] = self.create_stat_card(cards_frame, "Nieruchomo≈õci rolne", str(stats.get("rolne", "0")), 2)
        
        # Przyciski akcji
        actions_frame = ctk.CTkFrame(frame, fg_color="transparent")
        actions_frame.pack(fill="x", pady=18, padx=15) # Zwiƒôkszone marginesy
        
        upload_button = ctk.CTkButton(actions_frame, text="üìÑ Dodaj nowy PDF", 
                                     command=self.process_pdf,
                                     width=200,
                                     height=40,
                                     font=("Arial", 14))
        upload_button.pack(side="left", padx=25) # Zwiƒôkszony margines miƒôdzy przyciskami
        
        refresh_button = ctk.CTkButton(actions_frame, text="üîÑ Od≈õwie≈º dane", 
                                      width=150,
                                      height=40,
                                      font=("Arial", 14),
                                      command=self.refresh_data)
        refresh_button.pack(side="left", padx=10)
        
        # Dodajemy przycisk diagnostyki Chrome
        diagnostic_button = ctk.CTkButton(actions_frame, text="üîç Diagnostyka Chrome", 
                                       width=180,
                                       height=40,
                                       font=("Arial", 14),
                                       command=self.run_chrome_diagnostics,
                                       fg_color="#FF9800",  # pomara≈Ñczowy kolor dla wyr√≥≈ºnienia
                                       hover_color="#F57C00")
        diagnostic_button.pack(side="left")
        
        # Status operacji
        self.status_frame = ctk.CTkFrame(frame, fg_color="transparent")
        self.status_frame.pack(fill="x", pady=12, padx=15) # Dodane marginesy poziome
        
        self.status_label = ctk.CTkLabel(self.status_frame, text="", text_color="green")
        self.status_label.pack(pady=5) # Dodany padding pionowy
        
        # Sekcja z ostatnio przetwarzanymi plikami
        recent_frame = ctk.CTkFrame(frame)
        recent_frame.pack(fill="both", expand=True, pady=15, padx=15) # Dodane marginesy poziome
        
        recent_title = ctk.CTkLabel(recent_frame, text="Ostatnio przetwarzane pliki", font=("Arial", 16, "bold"))
        recent_title.pack(anchor="w", padx=20, pady=15) # Zwiƒôkszone marginesy
        
        self.recent_list_frame = ctk.CTkFrame(recent_frame, fg_color="transparent")
        self.recent_list_frame.pack(fill="both", expand=True, padx=20, pady=10) # Zwiƒôkszone marginesy
        
        self.update_recent_files_list()

        return frame
        
    def create_powiat_page(self, title):
        """Tworzy stronƒô dla danego powiatu"""
        frame = ctk.CTkFrame(self.pages_container)
        
        # Header z powiƒôkszonymi marginesami
        header = ctk.CTkFrame(frame, fg_color="transparent")
        header.pack(fill="x", pady=15, padx=15)  # Zwiƒôkszone marginesy
        
        label = ctk.CTkLabel(header, text=title, font=("Arial", 24, "bold"))
        label.pack(side="left", padx=15)  # Dodany padding poziomy
        
        # Liczba przetarg√≥w
        powiat_name = title.split(" ")[1]  # WyciƒÖgnij nazwƒô powiatu
        przetargi = self.get_przetargi_for_powiat(powiat_name)
        count_label = ctk.CTkLabel(header, 
                                text=f"Liczba przetarg√≥w: {len(przetargi)}", 
                                font=("Arial", 14))
        count_label.pack(side="right", padx=15)  # Dodany padding poziomy
        
        # Separator z marginesami
        separator = ctk.CTkFrame(frame, height=2)
        separator.pack(fill="x", pady=12, padx=15)  # Zwiƒôkszone marginesy
        
        # Kontener na dane przetarg√≥w z powiƒôkszonymi marginesami
        data_container = ctk.CTkFrame(frame)
        data_container.pack(fill="both", expand=True, pady=15, padx=15)  # Zwiƒôkszone marginesy
        
        # Zapisz referencjƒô do kontenera pod unikalnƒÖ nazwƒÖ dla tego powiatu
        setattr(self, f'{powiat_name.lower()}_data_container', data_container)
        
        # Dodaj dane przetarg√≥w (bƒôdƒÖ dodane przez update_powiat_data)
        
        return frame
        
    def create_stat_card(self, parent, title, value, position):
        card = ctk.CTkFrame(parent, width=150, height=100, corner_radius=10)
        card.pack(side="left", padx=10, pady=10)
        card.pack_propagate(False)
        
        value_label = ctk.CTkLabel(card, text=value, font=("Arial", 28, "bold"))
        value_label.pack(pady=(20, 5))
        
        title_label = ctk.CTkLabel(card, text=title, font=("Arial", 14))
        title_label.pack()
        
        return value_label  # Zwracamy etykietƒô z warto≈õciƒÖ, aby mo≈ºna by≈Ço jƒÖ p√≥≈∫niej aktualizowaƒá
        
    def get_stats(self):
        """Pobiera statystyki z pliku przetargi_najlepsze_oferty.json"""
        try:
            if not self.przetargi_data or "przetargi" not in self.przetargi_data:
                self.load_przetargi_data()
                
            przetargi = self.przetargi_data.get("przetargi", [])
            total = len(przetargi)
            
            # Zliczamy przetargi wed≈Çug r√≥≈ºnych kategorii
            active = 0
            rolne = 0
            
            # Aktualny dzie≈Ñ - 11 kwietnia 2025
            dzisiaj = datetime.datetime(2025, 4, 11)
            
            for p in przetargi:
                # Sprawdzamy czy przetarg jest aktywny (data przetargu jest w przysz≈Ço≈õci)
                try:
                    data_str = p.get("data_godzina", "").split("\n")[0]
                    if data_str:
                        data_parts = data_str.split(".")
                        if len(data_parts) >= 3:
                            # Format: DD.MM.YYYY
                            dzien, miesiac, rok = map(int, data_parts)
                            data_przetargu = datetime.datetime(rok, miesiac, dzien)
                            if data_przetargu > dzisiaj:
                                active += 1
                except (ValueError, IndexError):
                    pass
                    
                # Sprawdzamy czy to nieruchomo≈õƒá rolna
                if p.get("typ_nieruchomo≈õci", "").lower() == "rolna":
                    rolne += 1
            
            return {
                "total": total,
                "active": active,
                "rolne": rolne
            }
        except Exception as e:
            print(f"B≈ÇƒÖd podczas pobierania statystyk: {e}")
            return {"total": 0, "active": 0, "rolne": 0}

    def process_pdf(self):
        filepath = filedialog.askopenfilename(
            title="Wybierz plik PDF z przetargami",
            filetypes=[("Pliki PDF", "*.pdf")]
        )
        
        if filepath:
            # Poka≈º progres
            self.status_label.configure(text="Przetwarzanie...", text_color="#FFB74D")
            
            # Utworzenie progress baru
            progress_frame = ctk.CTkFrame(self.status_frame)
            progress_frame.pack(pady=10, fill="x", padx=30)
            
            progress = ctk.CTkProgressBar(progress_frame)
            progress.pack(fill="x", pady=5)
            progress.set(0)
            
            # Aktualizacja UI
            self.update()
            
            try:
                # Symulacja postƒôpu
                for i in range(11):
                    progress.set(i/10)
                    self.update()
                    self.after(100)  # Ma≈Ça pauza
                
                # Uruchomienie skrypt√≥w przetwarzajƒÖcych
                subprocess.run(["python", "pdfToText.py", filepath], check=True)
                
                for i in range(11):
                    progress.set(0.5 + i/20)
                    self.update()
                    self.after(100)
                    
                subprocess.run(["python", "filtruj_wszystko.py"], check=True)
                
                for i in range(11):
                    progress.set(0.75 + i/40)
                    self.update()
                    self.after(100)
                
                # Zako≈Ñczenie
                progress.set(1)
                self.update()
                self.after(300)
                
                # Dodaj do ostatnio przetwarzanych
                self.add_recent_file(os.path.basename(filepath))
                
                # Od≈õwie≈º dane po przetworzeniu - teraz z przetargi_najlepsze_oferty.json
                self.refresh_data()
                
                # Usu≈Ñ progress bar po zako≈Ñczeniu
                progress_frame.destroy()
                
                self.status_label.configure(text="‚úì Gotowe! Dane zaktualizowane.", text_color="#4CAF50")
                
            except subprocess.CalledProcessError:
                # Obs≈Çuga b≈Çƒôdu
                progress_frame.destroy()
                self.status_label.configure(text="‚ùå B≈ÇƒÖd podczas przetwarzania.", text_color="#F44336")

    def add_recent_file(self, filename):
        """Dodaje plik do listy ostatnio przetwarzanych"""
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
        self.recent_files.insert(0, {"name": filename, "date": timestamp})
        
        # Ogranicz do 5 najnowszych plik√≥w
        if len(self.recent_files) > 5:
            self.recent_files = self.recent_files[:5]
            
        # Zapisz do pamiƒôci
        self.save_recent_files()
        
        # Aktualizuj UI
        self.update_recent_files_list()
        
    def save_recent_files(self):
        """Zapisuje listƒô ostatnich plik√≥w"""
        try:
            with open(resource_path("recent_files.json"), "w", encoding="utf-8") as f:
                json.dump(self.recent_files, f, ensure_ascii=False)
        except Exception as e:
            print(f"B≈ÇƒÖd podczas zapisu ostatnich plik√≥w: {e}")
            
    def load_recent_files(self):
        """Wczytuje listƒô ostatnich plik√≥w"""
        try:
            with open(resource_path("recent_files.json"), "r", encoding="utf-8") as f:
                self.recent_files = json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            self.recent_files = []
            
    def update_recent_files_list(self):
        """Aktualizuje UI z listƒÖ ostatnich plik√≥w"""
        # Usu≈Ñ istniejƒÖce elementy
        for widget in self.recent_list_frame.winfo_children():
            widget.destroy()
            
        if not self.recent_files:
            no_files = ctk.CTkLabel(self.recent_list_frame, 
                                  text="Brak ostatnio przetwarzanych plik√≥w",
                                  text_color="gray50")
            no_files.pack(pady=20)
            return
            
        # Dodaj nag≈Ç√≥wki
        header = ctk.CTkFrame(self.recent_list_frame, fg_color="transparent")
        header.pack(fill="x", pady=(0, 5))
        
        ctk.CTkLabel(header, text="Nazwa pliku", width=350, anchor="w").pack(side="left", padx=(10, 0))
        ctk.CTkLabel(header, text="Data przetwarzania", width=200, anchor="w").pack(side="left")
        
        # Separator
        ctk.CTkFrame(self.recent_list_frame, height=1).pack(fill="x", pady=(0, 5))
        
        # Dodaj pliki
        for file_info in self.recent_files:
            file_row = ctk.CTkFrame(self.recent_list_frame, fg_color="transparent")
            file_row.pack(fill="x", pady=2)
            
            file_name = ctk.CTkLabel(file_row, text=file_info["name"], anchor="w", width=350)
            file_name.pack(side="left", padx=(10, 0))
            
            file_date = ctk.CTkLabel(file_row, text=file_info["date"], width=200, anchor="w")
            file_date.pack(side="left")

if __name__ == "__main__":
    app = PrzetargiApp()
    app.mainloop()
